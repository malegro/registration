
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>lab4Main</title>
      <meta name="generator" content="MATLAB 7.3">
      <meta name="date" content="2007-04-18">
      <meta name="m-file" content="lab4Main"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Getting Started</a></li>
               <li><a href="#2">Alien Probbing scan1 - scan1</a></li>
               <li><a href="#3">Alien Probbing scan1 - scan2</a></li>
               <li><a href="#4">Alien Probbing scan1 - scan3</a></li>
               <li><a href="#5">MRI - MRI 2 Registration</a></li>
               <li><a href="#6">MRI - MRI 2 Small ROI Registration</a></li>
               <li><a href="#7">MRI - CT Registration</a></li>
               <li><a href="#8">MRI - PET Registration</a></li>
               <li><a href="#9">Coarse-to-Fine</a></li>
               <li><a href="#10">Automated search</a></li>
            </ul>
         </div>
         <h2>Getting Started<a name="1"></a></h2><pre class="codeinput">close <span class="string">all</span>;

addpath(<span class="string">'/mit/6.555/matlab/reg/'</span>);

<span class="comment">% Load The data</span>
load_reg_data;

<span class="comment">% Display the medical images</span>
figure(655);clf;
display_image(mri,<span class="string">'MRI Subject 1'</span>);
figure(656);clf;
display_image(mri2,<span class="string">'MRI Subject 2'</span>);
figure(657);clf;
display_image(ct,<span class="string">'CT'</span>);
figure(658);clf;
display_image(pet,<span class="string">'PET'</span>);

<span class="comment">% Display the Alien brains</span>
figure(659);clf;
display_image(scan1,<span class="string">'Scan 1'</span>);
figure(660);clf;
display_image(scan2,<span class="string">'Scan 2'</span>);
figure(661);clf;
display_image(scan3,<span class="string">'Scan 3'</span>);

type <span class="string">sse</span>;
type <span class="string">sav</span>;
</pre><pre class="codeoutput">
function sse_score = sse(image1,image2)
%SSE  Sum of Squared Error/Intensity function template
%  SSE_SCORE = SSE(IMAGE1,IMAGE2) is an objective function that calculates the
%  sum of the squared difference in the pixel intensities of the two input
%  images, IMAGE1 and IMAGE2. IMAGE1 and IMAGE2 are both matrices. The output
%  SSE_SCORE is the sum of the squared error. 
%
%  You are responsible for updating this function to make it fully operational.

sse_score = sum((image1(:)-image2(:)).^2);


function sav_score = sav(image1, image2)
%SAV  Sum of Absolute Value function template
%  SAV_SCORE = SAV(IMAGE1,IMAGE2) is an objective function that calculates the
%  sum of the absolute value of the intensity difference between the pixels of
%  the two input images, IMAGE1 and IMAGE2. IMAGE1 and IMAGE2 are both matrices.
%  The output SAV_SCORE is the sum of the absolute value of the intensity
%  difference.
%
%  You are responsible for updating this function to make it fully operational.

sav_score = sum(abs(image1(:)-image2(:)));

</pre><img vspace="5" hspace="5" src="lab4Main_01.png"> <img vspace="5" hspace="5" src="lab4Main_02.png"> <img vspace="5" hspace="5" src="lab4Main_03.png"> <img vspace="5" hspace="5" src="lab4Main_04.png"> <img vspace="5" hspace="5" src="lab4Main_05.png"> <img vspace="5" hspace="5" src="lab4Main_06.png"> <img vspace="5" hspace="5" src="lab4Main_07.png"> <h2>Alien Probbing scan1 - scan1<a name="2"></a></h2><pre class="codeinput">fixed_image  = scan1;
moving_image = scan1;

<span class="comment">% Set ROI</span>
roi = ROI_ALIEN_BRAIN;

figure;
display_image(scan1,<span class="string">'scan1 w/ ROI'</span>);
hold <span class="string">on</span>;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],<span class="string">'r-'</span>);


<span class="comment">% Make a cell array of all objective functions you want to try out</span>
<span class="comment">% The @ specifies a function handle. Don't forget the @</span>
obj_functions = {@sse,@sav,@joint_entropy,@xcorr_coeff};

<span class="comment">% Specify the translations and rotations you want to probe</span>
<span class="comment">% For now just do dx,dy</span>
delta_xs   = linspace(-30,30,31);
delta_ys   = linspace(-30,30,31);
thetas     = 0;

<span class="comment">% Set this variable to 1 to show the image transformations as we probe</span>
ploton = -1;

<span class="comment">% Call function 'probe'</span>
surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot Results</span>
tIndx = 1;
[foo,cx] = min(abs(delta_xs));
[foo,cy] = min(abs(delta_ys));
sign = [1 1 1 -1];

<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,3,3);
  c = capture_region(sign(f)*surfaces{f}(:,:,tIndx),[cy;cx]);
  imagesc(delta_xs,delta_ys,c,[0 1]);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  p = 100*length(find(c(:)==1))/length(c(:));
  title([<span class="string">'Capture Region '</span> num2str(p) <span class="string">'%'</span>]);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="lab4Main_08.png"> <img vspace="5" hspace="5" src="lab4Main_09.png"> <img vspace="5" hspace="5" src="lab4Main_10.png"> <img vspace="5" hspace="5" src="lab4Main_11.png"> <img vspace="5" hspace="5" src="lab4Main_12.png"> <h2>Alien Probbing scan1 - scan2<a name="3"></a></h2><pre class="codeinput">fixed_image =  scan1;
moving_image = scan2;

<span class="comment">% Use Original ROI</span>
roi =  ROI_ALIEN_BRAIN;

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,31);
delta_ys   = linspace(-30,30,31);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;
sign = [1 1 1 -1];
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  <span class="comment">% Show the alignment for each</span>
  subplot(1,3,3);
  mi = global_extrema(sign(f)*surfaces{f});
  xi = mi{2}(1); yi = mi{1}(1);
  T_12{f} = [delta_xs(xi) delta_ys(yi) 0];
  display_alignment(scan1,image_transform(scan2,T_12{f})); axis <span class="string">off</span>;
  title([<span class="string">'scan1 - T(scan2), T = ['</span> num2str(T_12{f}) <span class="string">' ]'</span>]);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="lab4Main_13.png"> <img vspace="5" hspace="5" src="lab4Main_14.png"> <img vspace="5" hspace="5" src="lab4Main_15.png"> <img vspace="5" hspace="5" src="lab4Main_16.png"> <h2>Alien Probbing scan1 - scan3<a name="4"></a></h2><pre class="codeinput">fixed_image =  scan1;
moving_image = scan3;

<span class="comment">% Use Original ROI</span>
roi =  ROI_ALIEN_BRAIN;

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,31);
delta_ys   = linspace(-30,30,31);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;
sign = [1 1 1 -1];
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  <span class="comment">% Show the alignment for each</span>
  subplot(1,3,3);
  mi = global_extrema(sign(f)*surfaces{f});
  xi = mi{2}(1); yi = mi{1}(1);
  T_13{f} = [delta_xs(xi) delta_ys(yi) 0];
  display_alignment(scan1,image_transform(scan3,T_13{f})); axis <span class="string">off</span>;
  title([<span class="string">'scan1 - T(scan3), T = ['</span> num2str(T_13{f}) <span class="string">' ]'</span>]);
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="lab4Main_17.png"> <img vspace="5" hspace="5" src="lab4Main_18.png"> <img vspace="5" hspace="5" src="lab4Main_19.png"> <img vspace="5" hspace="5" src="lab4Main_20.png"> <h2>MRI - MRI 2 Registration<a name="5"></a></h2><pre class="codeinput"><span class="comment">% Align MRI and MRI 2</span>
fixed_image =  mri;
moving_image = mri2;

<span class="comment">% Use Original ROI</span>
roi =  ROI_MRI;

figure;
display_image(mri,<span class="string">'MRI w/  ROI'</span>);
hold <span class="string">on</span>;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],<span class="string">'r-'</span>);

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,21);
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
<span class="keyword">end</span>

<span class="comment">% Looking at our results we see all techniques have a local or global</span>
<span class="comment">% extrema around dx=5 to 15 and dy=0 to 10 or so. Now we will do a 3D alignment</span>
<span class="comment">% In this region.</span>
delta_xs = [5:15];
delta_ys = [0:10];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

  <span class="comment">% View the joint entropy using the volumeslicer</span>
volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});

<span class="comment">% There seems to be a strong global min in joint entropy</span>
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_mri2 = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(mri2,T_mri2)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'MRI + T(MRI2), T = ['</span> num2str(T_mri2) <span class="string">' ]'</span>]);
</pre><pre class="codeoutput">
T_mri2 =

  10.000000000000000   6.000000000000000  -0.196349540849362

</pre><img vspace="5" hspace="5" src="lab4Main_21.png"> <img vspace="5" hspace="5" src="lab4Main_22.png"> <img vspace="5" hspace="5" src="lab4Main_23.png"> <img vspace="5" hspace="5" src="lab4Main_24.png"> <img vspace="5" hspace="5" src="lab4Main_25.png"> <img vspace="5" hspace="5" src="lab4Main_26.png"> <img vspace="5" hspace="5" src="lab4Main_27.png"> <h2>MRI - MRI 2 Small ROI Registration<a name="6"></a></h2><pre class="codeinput"><span class="comment">% Align MRI and MR 2</span>
fixed_image =  mri;
moving_image = mri2;

<span class="comment">% Use Small ROI</span>
roi =  [96 141 85 155];

figure;
display_image(mri,<span class="string">'MRI w/ small ROI'</span>);
hold <span class="string">on</span>;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],<span class="string">'r-'</span>);


<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,21);
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
<span class="keyword">end</span>

<span class="comment">% Looking at our results now it is hard to tell where the optimal point is.</span>
<span class="comment">% Joint entropy gets dx correct, and is close to 10, by dy is is hard to</span>
<span class="comment">% tell. For the lab you don't have to get a final alignment, but just out</span>
<span class="comment">% of curiosity let's search a region we know has the correct solution and</span>
<span class="comment">% Find the best alignment with joint entropy</span>
delta_xs = [5:15];
delta_ys = [0:10];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

  <span class="comment">% View the joint entropy using the volumeslicer</span>
volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});

<span class="comment">% There seems to be a strong global min in joint entropy</span>
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_mri2 = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(mri2,T_mri2)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'MRI, T(MRI2) small ROI, T = ['</span> num2str(T_mri2) <span class="string">' ]'</span>]);

<span class="comment">% As you can tell, this doesn't get the correct alignment. This shows how</span>
<span class="comment">% difficult registration may be if you don't have that much information.</span>
<span class="comment">% Normally the ROI includes the outside boundary of the brain which is a</span>
<span class="comment">% strong cue about whether or not you are aligned properly.</span>
</pre><pre class="codeoutput">
T_mri2 =

   6.000000000000000   1.000000000000000   0.392699081698724

</pre><img vspace="5" hspace="5" src="lab4Main_28.png"> <img vspace="5" hspace="5" src="lab4Main_29.png"> <img vspace="5" hspace="5" src="lab4Main_30.png"> <img vspace="5" hspace="5" src="lab4Main_31.png"> <img vspace="5" hspace="5" src="lab4Main_32.png"> <img vspace="5" hspace="5" src="lab4Main_33.png"> <img vspace="5" hspace="5" src="lab4Main_34.png"> <h2>MRI - CT Registration<a name="7"></a></h2><pre class="codeinput">fixed_image =  mri;
moving_image = ct;

<span class="comment">% Use Original ROI</span>
roi =  ROI_MRI;

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,21);
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;

<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
<span class="keyword">end</span>

<span class="comment">% Looking at joint entropy it has a local min that seems promising at</span>
<span class="comment">% dx=3 and dy=12 w/ a wide valuly where dx can change with little effect</span>
<span class="comment">% Let's explore this region in 3D</span>
delta_xs = [0:20];
delta_ys = [5:15];
thetas   = linspace(-pi/4, pi/4,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

 <span class="comment">% View the joint entropy using the volumeslicer</span>
volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});

<span class="comment">% After doing that it seems we are right on the edge with theta = pi/8, so</span>
<span class="comment">% let's expand our search a little</span>
thetas = linspace(0,pi/4,9);
surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

  <span class="comment">% View the joint entropy using the volumeslicer</span>
volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});


<span class="comment">% There seems to be a strong global min in joint entropy</span>
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_ct = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(ct,T_ct)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'MRI + T(CT), T = ['</span> num2str(T_ct) <span class="string">' ]'</span>]);
</pre><pre class="codeoutput">
T_ct =

  15.000000000000000   9.000000000000000   0.392699081698724

</pre><img vspace="5" hspace="5" src="lab4Main_35.png"> <img vspace="5" hspace="5" src="lab4Main_36.png"> <img vspace="5" hspace="5" src="lab4Main_37.png"> <img vspace="5" hspace="5" src="lab4Main_38.png"> <img vspace="5" hspace="5" src="lab4Main_39.png"> <img vspace="5" hspace="5" src="lab4Main_40.png"> <h2>MRI - PET Registration<a name="8"></a></h2><pre class="codeinput">fixed_image =  mri;
moving_image = pet;

<span class="comment">% Use Original ROI</span>
roi =  ROI_MRI;

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = linspace(-30,30,21);
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
<span class="keyword">end</span>

<span class="comment">% Looking at joint entropy it has a clear local minimum at dx = -12 and</span>
<span class="comment">% dy=-6. We will explore this area in 3D</span>
delta_xs = [-20:-10];
delta_ys = [-10:0];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% View the joint entropy using the volumeslicer</span>
h = volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});

<span class="comment">% There seems to be a strong global min in joint entropy again</span>
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_pet = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(pet,T_pet)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'MRI + T(PET), T = ['</span> num2str(T_pet) <span class="string">' ]'</span>]);
</pre><pre class="codeoutput">
T_pet =

 -13.000000000000000  -5.000000000000000  -0.196349540849362

</pre><img vspace="5" hspace="5" src="lab4Main_41.png"> <img vspace="5" hspace="5" src="lab4Main_42.png"> <img vspace="5" hspace="5" src="lab4Main_43.png"> <img vspace="5" hspace="5" src="lab4Main_44.png"> <img vspace="5" hspace="5" src="lab4Main_45.png"> <img vspace="5" hspace="5" src="lab4Main_46.png"> <h2>Coarse-to-Fine<a name="9"></a></h2><pre class="codeinput">D = 8;
<span class="comment">% Downsample the images. Use the 'bilinear' option so that imresize</span>
<span class="comment">% uses a lowpass filter.</span>
mri_d = imresize(mri,1/D,<span class="string">'bilinear'</span>,20);
mri2_d = imresize(mri2,1/D,<span class="string">'bilinear'</span>,20);
figure;
subplot(1,2,1); display_image(mri_d,<span class="string">'MRI Downsampled'</span>);
subplot(1,2,2); display_image(mri2_d, <span class="string">'MRI2 Downsampled'</span>);

<span class="comment">% Align MRI and MRI_Trunc downsampled</span>
fixed_image =  mri_d;
moving_image = mri2_d;

<span class="comment">% Use Original ROI</span>
roi =  ROI_MRI/D;

<span class="comment">% First we will do a quick translation only alignment</span>
delta_xs   = -4:4;
delta_ys   = -4:4;
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% Plot the resulting surfaces</span>
tIndx = 1;
<span class="keyword">for</span> f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,<span class="string">'Position'</span>,[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap <span class="string">default</span>; colorbar;
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>); zlabel(func2str(obj_functions{f}),<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
  title([<span class="string">'Probe surface using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);

  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,<span class="string">'lineWidth'</span>,1);colormap <span class="string">default</span>;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold <span class="string">on</span>;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),<span class="string">'kx'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),<span class="string">'ko'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),<span class="string">'kd'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),<span class="string">'ks'</span>,<span class="string">'lineWidth'</span>,2,<span class="string">'MarkerSize'</span>,12);
  xlabel(<span class="string">'\delta_x'</span>);ylabel(<span class="string">'\delta_y'</span>);
  title([<span class="string">'Probe surface contours using '</span> func2str(obj_functions{f})],<span class="string">'interpreter'</span>,<span class="string">'none'</span>);
<span class="keyword">end</span>

<span class="comment">% Looking at our resultsit's there are a few global extrema, most show up</span>
<span class="comment">% around dx in the range from 0 to 2 and dy between -1 and 1.</span>
<span class="comment">% So let's do a coarse search over the 3D space in that area.</span>
delta_xs = [0:2];
delta_ys = [-1:1];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, <span class="keyword">...</span>
                 delta_xs,delta_ys,thetas,ploton);

<span class="comment">% View the joint entropy using the volumeslicer</span>
volumeslicer(surfaces{3},<span class="string">'DimNames'</span>,{<span class="string">'dy'</span>,<span class="string">'dx'</span>,<span class="string">'theta'</span>},<span class="string">'DimRanges'</span>,{delta_ys,delta_xs,thetas});

<span class="comment">% It's not so easy to see in the volume slicer tool. It doesn't look so</span>
<span class="comment">% smooth. Let's just get the global minimum</span>
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_d = [delta_xs(xi) delta_ys(yi) thetas(zi)]
T_d2 = T_d .* [D D 1];

figure;
subplot(2,1,1);
display_alignment(mri_d,image_transform(mri2_d,T_d)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'Coarse MRI + T(MRI 2), T = ['</span> num2str(T_d) <span class="string">' ]'</span>]);
subplot(2,1,2);
display_alignment(mri,image_transform(mri2,T_d2)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'Coarse MRI + T(MRI 2) in Full Res, T = ['</span> num2str(T_d2) <span class="string">' ]'</span>]);

<span class="comment">% This was achieved with much less computation. This gives a decent</span>
<span class="comment">% alignment, but not that great. We could further</span>
</pre><pre class="codeoutput">
T_d =

   1.000000000000000   1.000000000000000  -0.392699081698724

</pre><img vspace="5" hspace="5" src="lab4Main_47.png"> <img vspace="5" hspace="5" src="lab4Main_48.png"> <img vspace="5" hspace="5" src="lab4Main_49.png"> <img vspace="5" hspace="5" src="lab4Main_50.png"> <img vspace="5" hspace="5" src="lab4Main_51.png"> <img vspace="5" hspace="5" src="lab4Main_52.png"> <img vspace="5" hspace="5" src="lab4Main_53.png"> <h2>Automated search<a name="10"></a></h2><pre class="codeinput"><span class="comment">% For this use the entire image as the ROI</span>
roi =  ROI_MRI;

<span class="comment">% This is my wrapper function</span>
type <span class="string">wrapper.m</span>

<span class="comment">% Next try MRI CT</span>
opt = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>);
T_ct_search = fminsearch6555(@(x) wrapper(x,mri,ct,@joint_entropy,roi),[30 30 0],[5 5 pi/16],opt)

figure;
display_alignment(mri,image_transform(ct,T_ct_search)); axis <span class="string">off</span>;
colormap <span class="string">gray</span>;
title([<span class="string">'MRI + T(CT) search, T = ['</span> num2str(T_ct_search) <span class="string">' ]'</span>]);
</pre><pre class="codeoutput">
function f = wrapper(params,im1,im2,obj_f,roi)
 
   if isempty(roi), roi = [1 size(im1,2) 1 size(im2,1)]; end
   
   roiX   = roi(1):roi(2);
   roiY   = roi(3):roi(4);
   
   im2t = image_transform(im2,params);
   
   f = obj_f(im1(roiY,roiX),im2t(roiY,roiX));
   
   if 0
     figure(655);
     display_alignment(im1,im2t); hold on;
     plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],'r-');
     hold off;
     drawnow;
   end

 
 Iteration   Func-count     min f(x)         Procedure
     0            1          4.51281         
     1            4          4.51281         initial simplex
     2            6          4.46573         expand
     3            7          4.46573         reflect
     4            9            4.373         expand
     5           10            4.373         reflect
     6           11            4.373         reflect
     7           13            4.373         contract outside
     8           15            4.373         contract inside
     9           17           4.2767         expand
    10           18           4.2767         reflect
    11           20          4.21488         reflect
    12           22           4.0148         reflect
    13           23           4.0148         reflect
    14           24           4.0148         reflect
    15           26           4.0148         contract inside
    16           28          3.94655         contract inside
    17           30          3.91966         contract inside
    18           32          3.91966         contract outside
    19           34          3.88782         contract outside
    20           36          3.87047         contract inside
    21           38          3.87047         contract inside
    22           40          3.85054         contract inside
    23           41          3.85054         reflect
    24           43          3.83505         reflect
    25           45          3.83505         contract inside
    26           47          3.83505         contract inside
    27           49          3.82964         contract inside
    28           51          3.82902         contract outside
    29           53          3.82902         contract inside
    30           55          3.82696         contract outside
    31           57          3.82696         contract inside
    32           59          3.82484         contract inside
    33           61          3.82484         contract inside
    34           63          3.82401         reflect
    35           65          3.82401         contract inside
    36           66          3.82401         reflect
    37           68          3.82401         contract inside
    38           70          3.82383         reflect
    39           71          3.82383         reflect
    40           73          3.82279         contract inside
    41           75          3.82279         contract inside
    42           77          3.82279         contract inside
    43           79          3.82279         contract inside
    44           81          3.82279         contract outside
    45           82          3.82279         reflect
    46           83          3.82279         reflect
    47           85          3.82244         contract inside
    48           87          3.82244         contract inside
    49           89          3.82244         contract inside
    50           94          3.82244         shrink
    51           96          3.82193         contract inside
    52           97          3.82193         reflect
    53           99          3.82193         contract inside
    54          100          3.82193         reflect
    55          102          3.82193         contract inside
    56          107          3.82193         shrink
    57          109          3.82193         contract inside
    58          114          3.82193         shrink
    59          116          3.82193         contract inside
    60          117          3.82193         reflect
    61          118          3.82193         reflect
    62          123          3.82193         shrink
    63          124          3.82193         reflect
    64          125          3.82193         reflect
    65          126          3.82193         reflect
    66          128          3.82193         contract outside
    67          130          3.82192         reflect
    68          132          3.82192         contract inside
    69          137          3.82192         shrink
 
Optimization terminated:
 the current x satisfies the termination criteria using OPTIONS.TolX of 1.000000e-04 
 and F(X) satisfies the convergence criteria using OPTIONS.TolFun of 1.000000e-04 


T_ct_search =

  14.793041954214102   9.206959923688364   0.398086065569921

</pre><img vspace="5" hspace="5" src="lab4Main_54.png"> <p class="footer"><br>
            Published with MATLAB&reg; 7.3<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Getting Started

close all;

addpath('/mit/6.555/matlab/reg/');

% Load The data
load_reg_data;

% Display the medical images
figure(655);clf;
display_image(mri,'MRI Subject 1');
figure(656);clf;
display_image(mri2,'MRI Subject 2');
figure(657);clf;
display_image(ct,'CT');
figure(658);clf;
display_image(pet,'PET');

% Display the Alien brains
figure(659);clf;
display_image(scan1,'Scan 1');
figure(660);clf;
display_image(scan2,'Scan 2');
figure(661);clf;
display_image(scan3,'Scan 3');

type sse;
type sav;


%% Alien Probbing scan1 - scan1
fixed_image  = scan1;
moving_image = scan1; 

% Set ROI
roi = ROI_ALIEN_BRAIN;

figure;
display_image(scan1,'scan1 w/ ROI');
hold on;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],'r-'); 


% Make a cell array of all objective functions you want to try out
% The @ specifies a function handle. Don't forget the @
obj_functions = {@sse,@sav,@joint_entropy,@xcorr_coeff};
  
% Specify the translations and rotations you want to probe
% For now just do dx,dy
delta_xs   = linspace(-30,30,31); 
delta_ys   = linspace(-30,30,31);
thetas     = 0;

% Set this variable to 1 to show the image transformations as we probe
ploton = -1;

% Call function 'probe'
surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);
               
% Plot Results
tIndx = 1;
[foo,cx] = min(abs(delta_xs));
[foo,cy] = min(abs(delta_ys));
sign = [1 1 1 -1];

for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,3,3);
  c = capture_region(sign(f)*surfaces{f}(:,:,tIndx),[cy;cx]);
  imagesc(delta_xs,delta_ys,c,[0 1]);
  xlabel('\delta_x');ylabel('\delta_y');
  p = 100*length(find(c(:)==1))/length(c(:));
  title(['Capture Region ' num2str(p) '%']);
end

%%  Alien Probbing scan1 - scan2 

fixed_image =  scan1;
moving_image = scan2;

% Use Original ROI
roi =  ROI_ALIEN_BRAIN;

% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,31); 
delta_ys   = linspace(-30,30,31);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% Plot the resulting surfaces
tIndx = 1;
sign = [1 1 1 -1];
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');

  % Show the alignment for each
  subplot(1,3,3);
  mi = global_extrema(sign(f)*surfaces{f});
  xi = mi{2}(1); yi = mi{1}(1);
  T_12{f} = [delta_xs(xi) delta_ys(yi) 0];
  display_alignment(scan1,image_transform(scan2,T_12{f})); axis off;
  title(['scan1 - T(scan2), T = [' num2str(T_12{f}) ' ]']);
end


%%  Alien Probbing scan1 - scan3

fixed_image =  scan1;
moving_image = scan3;

% Use Original ROI
roi =  ROI_ALIEN_BRAIN;

% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,31); 
delta_ys   = linspace(-30,30,31);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% Plot the resulting surfaces
tIndx = 1;
sign = [1 1 1 -1];
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');

  % Show the alignment for each
  subplot(1,3,3);
  mi = global_extrema(sign(f)*surfaces{f});
  xi = mi{2}(1); yi = mi{1}(1);
  T_13{f} = [delta_xs(xi) delta_ys(yi) 0];
  display_alignment(scan1,image_transform(scan3,T_13{f})); axis off;
  title(['scan1 - T(scan3), T = [' num2str(T_13{f}) ' ]']);
end
%% MRI - MRI 2 Registration

% Align MRI and MRI 2
fixed_image =  mri;
moving_image = mri2;

% Use Original ROI
roi =  ROI_MRI;

figure;
display_image(mri,'MRI w/  ROI');
hold on;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],'r-');

% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,21); 
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% Plot the resulting surfaces
tIndx = 1;
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
end

% Looking at our results we see all techniques have a local or global
% extrema around dx=5 to 15 and dy=0 to 10 or so. Now we will do a 3D alignment
% In this region.
delta_xs = [5:15];
delta_ys = [0:10];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

  % View the joint entropy using the volumeslicer
volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});
              
% There seems to be a strong global min in joint entropy
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_mri2 = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(mri2,T_mri2)); axis off;
colormap gray;
title(['MRI + T(MRI2), T = [' num2str(T_mri2) ' ]']);


%% MRI - MRI 2 Small ROI Registration

% Align MRI and MR 2
fixed_image =  mri;
moving_image = mri2;

% Use Small ROI
roi =  [96 141 85 155];

figure;
display_image(mri,'MRI w/ small ROI');
hold on;
plot([roi(1) roi(1) roi(2) roi(2) roi(1)],[roi(3) roi(4) roi(4) roi(3) roi(3)],'r-');


% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,21); 
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% Plot the resulting surfaces
tIndx = 1;
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
end

% Looking at our results now it is hard to tell where the optimal point is.
% Joint entropy gets dx correct, and is close to 10, by dy is is hard to
% tell. For the lab you don't have to get a final alignment, but just out
% of curiosity let's search a region we know has the correct solution and
% Find the best alignment with joint entropy
delta_xs = [5:15];
delta_ys = [0:10];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

  % View the joint entropy using the volumeslicer
volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});
              
% There seems to be a strong global min in joint entropy
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_mri2 = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(mri2,T_mri2)); axis off;
colormap gray;
title(['MRI, T(MRI2) small ROI, T = [' num2str(T_mri2) ' ]']);

% As you can tell, this doesn't get the correct alignment. This shows how
% difficult registration may be if you don't have that much information.
% Normally the ROI includes the outside boundary of the brain which is a
% strong cue about whether or not you are aligned properly.

%% MRI - CT Registration
fixed_image =  mri;
moving_image = ct;

% Use Original ROI
roi =  ROI_MRI;

% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,21); 
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);
               
% Plot the resulting surfaces
tIndx = 1;

for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
end

% Looking at joint entropy it has a local min that seems promising at
% dx=3 and dy=12 w/ a wide valuly where dx can change with little effect
% Let's explore this region in 3D
delta_xs = [0:20];
delta_ys = [5:15];
thetas   = linspace(-pi/4, pi/4,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

 % View the joint entropy using the volumeslicer
volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});

% After doing that it seems we are right on the edge with theta = pi/8, so
% let's expand our search a little
thetas = linspace(0,pi/4,9);
surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);
 
  % View the joint entropy using the volumeslicer
volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});
              
               
% There seems to be a strong global min in joint entropy
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_ct = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(ct,T_ct)); axis off;
colormap gray;
title(['MRI + T(CT), T = [' num2str(T_ct) ' ]']);

%% MRI - PET Registration
fixed_image =  mri;
moving_image = pet;

% Use Original ROI
roi =  ROI_MRI;

% First we will do a quick translation only alignment
delta_xs   = linspace(-30,30,21); 
delta_ys   = linspace(-30,30,21);
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);
               
% Plot the resulting surfaces
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,3,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,3,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
end

% Looking at joint entropy it has a clear local minimum at dx = -12 and
% dy=-6. We will explore this area in 3D
delta_xs = [-20:-10];
delta_ys = [-10:0];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% View the joint entropy using the volumeslicer
h = volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});
               
% There seems to be a strong global min in joint entropy again
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_pet = [delta_xs(xi) delta_ys(yi) thetas(zi)]

figure;
display_alignment(mri,image_transform(pet,T_pet)); axis off;
colormap gray;
title(['MRI + T(PET), T = [' num2str(T_pet) ' ]']);

%% Coarse-to-Fine
D = 8;
% Downsample the images. Use the 'bilinear' option so that imresize
% uses a lowpass filter.
mri_d = imresize(mri,1/D,'bilinear',20);
mri2_d = imresize(mri2,1/D,'bilinear',20);
figure;
subplot(1,2,1); display_image(mri_d,'MRI Downsampled');
subplot(1,2,2); display_image(mri2_d, 'MRI2 Downsampled');

% Align MRI and MRI_Trunc downsampled
fixed_image =  mri_d;
moving_image = mri2_d;

% Use Original ROI
roi =  ROI_MRI/D;

% First we will do a quick translation only alignment
delta_xs   = -4:4; 
delta_ys   = -4:4;
thetas     = 0;

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% Plot the resulting surfaces
tIndx = 1;
for f=1:length(obj_functions)
  figure(655+f); clf; set(gcf,'Position',[1 1 1200 300]);
  subplot(1,2,1);
  surf(delta_xs,delta_ys,surfaces{f}(:,:,tIndx)); colormap default; colorbar;
  xlabel('\delta_x');ylabel('\delta_y'); zlabel(func2str(obj_functions{f}),'interpreter','none');
  title(['Probe surface using ' func2str(obj_functions{f})],'interpreter','none');
  
  subplot(1,2,2);
  contour(delta_xs,delta_ys,surfaces{f}(:,:,tIndx),100,'lineWidth',1);colormap default;
  [mis,mxs] = local_extrema(surfaces{f}(:,:,tIndx));
  [gmi,gmx] = global_extrema(surfaces{f}(:,:,tIndx));
  hold on;
  plot(delta_xs(mxs{2}),delta_ys(mxs{1}),'kx','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(mis{2}),delta_ys(mis{1}),'ko','lineWidth',2,'MarkerSize',8);
  plot(delta_xs(gmx{2}),delta_ys(gmx{1}),'kd','lineWidth',2,'MarkerSize',12);
  plot(delta_xs(gmi{2}),delta_ys(gmi{1}),'ks','lineWidth',2,'MarkerSize',12);
  xlabel('\delta_x');ylabel('\delta_y');
  title(['Probe surface contours using ' func2str(obj_functions{f})],'interpreter','none');
end

% Looking at our resultsit's there are a few global extrema, most show up
% around dx in the range from 0 to 2 and dy between -1 and 1. 
% So let's do a coarse search over the 3D space in that area.
delta_xs = [0:2];
delta_ys = [-1:1];
thetas   = linspace(-pi/8, pi/8,9);

surfaces = probe(fixed_image, moving_image, roi, obj_functions, ...
                 delta_xs,delta_ys,thetas,ploton);

% View the joint entropy using the volumeslicer
volumeslicer(surfaces{3},'DimNames',{'dy','dx','theta'},'DimRanges',{delta_ys,delta_xs,thetas});
              
% It's not so easy to see in the volume slicer tool. It doesn't look so
% smooth. Let's just get the global minimum
mi = global_extrema(surfaces{3});
xi = mi{2}(1); yi = mi{1}(1); zi=mi{3}(1);
T_d = [delta_xs(xi) delta_ys(yi) thetas(zi)]
T_d2 = T_d .* [D D 1];

figure;
subplot(2,1,1);
display_alignment(mri_d,image_transform(mri2_d,T_d)); axis off;
colormap gray;
title(['Coarse MRI + T(MRI 2), T = [' num2str(T_d) ' ]']);
subplot(2,1,2);
display_alignment(mri,image_transform(mri2,T_d2)); axis off;
colormap gray;
title(['Coarse MRI + T(MRI 2) in Full Res, T = [' num2str(T_d2) ' ]']);

% This was achieved with much less computation. This gives a decent 
% alignment, but not that great. We could further

%% Automated search

% For this use the entire image as the ROI
roi =  ROI_MRI;

% This is my wrapper function
type wrapper.m

% Next try MRI CT
opt = optimset('Display','iter');
T_ct_search = fminsearch6555(@(x) wrapper(x,mri,ct,@joint_entropy,roi),[30 30 0],[5 5 pi/16],opt)

figure;
display_alignment(mri,image_transform(ct,T_ct_search)); axis off;
colormap gray;
title(['MRI + T(CT) search, T = [' num2str(T_ct_search) ' ]']);

##### SOURCE END #####
-->
   </body>
</html>